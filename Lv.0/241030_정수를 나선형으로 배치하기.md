# 241030 정수를 나선형으로 배치하기

### ☀️ 문제 설명

양의 정수 `n`이 매개변수로 주어집니다. `n` × `n` 배열에 1부터 `n`2 까지 정수를 인덱스 [0][0]부터 시계방향 나선형으로 배치한 이차원 배열을 return 하는 solution 함수를 작성해 주세요.

---

### ☀️ **제한사항**

- 1 ≤ `n` ≤ 30

---

### ☀️ **입출력 예**

| n | result |
| --- | --- |
| 4 | [[1, 2, 3, 4], [12, 13, 14, 5], [11, 16, 15, 6], [10, 9, 8, 7]] |
| 5 | [[1, 2, 3, 4, 5], [16, 17, 18, 19, 6], [15, 24, 25, 20, 7], [14, 23, 22, 21, 8], [13, 12, 11, 10, 9]] |

---

### ☀️ **입출력 예 설명**

입출력 예 #1

- 예제 1번의 `n`의 값은 4로 4 × 4 배열에 다음과 같이 1부터 16까지 숫자를 채울 수 있습니다.
    
    
    | 행 \ 열 | 0 | 1 | 2 | 3 |
    | --- | --- | --- | --- | --- |
    | 0 | 1 | 2 | 3 | 4 |
    | 1 | 12 | 13 | 14 | 5 |
    | 2 | 11 | 16 | 15 | 6 |
    | 3 | 10 | 9 | 8 | 7 |
    
    따라서 [[1, 2, 3, 4], [12, 13, 14, 5], [11, 16, 15, 6], [10, 9, 8, 7]]를 return 합니다.
    

입출력 예 #2

- 예제 2번의 `n`의 값은 5로 5 × 5 배열에 다음과 같이 1부터 25까지 숫자를 채울 수 있습니다.
    
    
    | 행 \ 열 | 0 | 1 | 2 | 3 | 4 |
    | --- | --- | --- | --- | --- | --- |
    | 0 | 1 | 2 | 3 | 4 | 5 |
    | 1 | 16 | 17 | 18 | 19 | 6 |
    | 2 | 15 | 24 | 25 | 20 | 7 |
    | 3 | 14 | 23 | 22 | 21 | 8 |
    | 4 | 13 | 12 | 11 | 10 | 9 |
    
    따라서 [[1, 2, 3, 4, 5], [16, 17, 18, 19, 6], [15, 24, 25, 20, 7], [14, 23, 22, 21, 8], [13, 12, 11, 10, 9]]를 return 합니다.
    

---

### ☀️ 풀이

```jsx
function solution(n) {
    const answer = [];
    for(let i = 0; i < n; i++) answer.push(Array(n).fill(0));
    
    const direction = [[0,1],[1,0],[0,-1],[-1,0]];
    
    let count = 1;
    let x = 0;
    let y = 0; 
    let now = 0;
    
    while(count <= n*n){
        answer[y][x] = count;
        ++count;
        
        let newY = y + direction[now][0];
        let newX = x + direction[now][1];
        
        if(newY < 0 || newY >= n || newX < 0 || newX >= n || answer[newY][newX] !== 0) {
            now = (now+1) % 4;
            newY = y + direction[now][0];
            newX = x + direction[now][1];
        }
        y = newY;
        x = newX;
    }
    
    return answer;
}
```

✍️ 방향을 전환해야 하는 조건인 이동하려는 다음 위치가 배열의 범위 내에 있는지, 그리고 해당 위치에 이미 값이 할당되었는지의 조건이 떠오르지 않아서 검색해서 풀었다. `if(newY < 0 || newY >= n || newX < 0 || newX >= n || answer[newY][newX] !== 0)` 이런 식으로 조건을 주면 만족한다.